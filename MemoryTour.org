* A Guide to the Memory Model

The memory model is split up into numerous modules across several
files. At a high level the important aspects of the code for the memory model consists of:

- The abstract specification of memory
- The concrete implementation of a memory model (that agrees with the specification)
- Serialization / deserialization of values into bytes

** Important Files

- [[file:src/coq/Handlers/MemoryModel.v::From Vellvm.Syntax Require Import][src/coq/Handlers/MemoryModel.v]]

*** Other Relevant Files

- DynamicValues.v

** Memory Specification

There is a specification for memory models in [[file:src/coq/Handlers/MemoryModel.v::From Vellvm.Syntax Require
 Import][src/coq/Handlers/MemoryModel.v]]. Any implementation of an LLVM memory
model must abide by this specification.

The specification is broken up into two modules:

- [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelSpecPrimitives]]
- [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpec (LP : LLVMParams) (MP : MemoryParams LP) (MMSP : MemoryModelSpecPrimitives LP MP).][MemoryModelSpec]]

When implementing a custom memory model for LLVM in our framework an
instance of [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelSpecPrimitives]] must be provided. This specifies
the low level structure of memory, and some operations on the memory,
such as reading symbolic bytes from memory.

[[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpec (LP : LLVMParams) (MP : MemoryParams LP) (MMSP : MemoryModelSpecPrimitives LP MP).][MemoryModelSpec]] is derived from [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelSpecPrimitives]]. It defines
a number of predicates for each of the higher level operations on
memory. All of these predicates are defined in terms of [[file:src/coq/Handlers/MemPropT.v::Definition MemPropT (MemState : Type) (X : Type) : Type][MemPropT]]:

#+begin_src coq
  Definition MemPropT (MemState : Type) (X : Type) : Type
    := MemState -> err_ub_oom (MemState * X)%type -> Prop.
#+end_src

So, for instance:

#+begin_src coq
  Definition read_byte_spec_MemPropT (ptr : addr) : MemPropT MemState SByte
#+end_src

Will specify what the valid behaviour for reading a symbolic byte from
memory at ~ptr~ is given a specific state of memory. The ~err_ub_oom~
that we see in the definition of ~MemPropT~ is just an error monad
allowing for errors, undefined behaviour, and out of memory to be
raised instead of a value being returned along with a new memory
state.

Within [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelSpec (LP : LLVMParams) (MP : MemoryParams LP) (MMSP : MemoryModelSpecPrimitives LP MP).][MemoryModelSpec]] the interesting high level definitions are as follows:

- [[file:src/coq/Handlers/MemoryModel.v::Definition read_byte_spec_MemPropT (ptr : addr) : MemPropT MemState SByte :=][read_byte_spec_MemPropT]]
  + Reading a byte at an address
- [[file:src/coq/Handlers/MemoryModel.v::Definition mempush_spec_MemPropT : MemPropT MemState unit :=][mempush_spec_MemPropT]]
  + Pushing a fresh stack frame
- [[file:src/coq/Handlers/MemoryModel.v::Definition mempop_spec_MemPropT : MemPropT MemState unit :=][mempop_spec_MemPropT]]
  + Pop a stack frame
- [[file:src/coq/Handlers/MemoryModel.v::Definition write_byte_spec_MemPropT (ptr : addr) (byte : SByte) : MemPropT MemState unit][write_byte_spec_MemPropT]]
  + Write a symbolic byte to an address in memory
- [[file:src/coq/Handlers/MemoryModel.v::Definition allocate_bytes_spec_MemPropT (t : dtyp) (init_bytes : list SByte)][allocate_bytes_spec_MemPropT]]
  + Allocate bytes onto the stack
- [[file:src/coq/Handlers/MemoryModel.v::Definition malloc_bytes_spec_MemPropT (init_bytes : list SByte)][malloc_bytes_spec_MemPropT]]
  + Allocate bytes onto the heap
- [[file:src/coq/Handlers/MemoryModel.v::Definition free_spec_MemPropT (root : addr) : MemPropT MemState unit :=][free_spec_MemPropT]]
  + Free heap allocated blocks

Many of these are actually wrappers around a ~Record~ definition which
contains the actual meat of the specification for these operations on
memory.

The above operations are then used to specify loading / storing full
symbolic values in memory, as well as allocations of types:

- [[file:src/coq/Handlers/MemoryModel.v::Definition read_uvalue_spec (dt : dtyp) (ptr : addr) : MemPropT MemState uvalue :=][read_uvalue_spec]]
- [[file:src/coq/Handlers/MemoryModel.v::Definition write_uvalue_spec (dt : dtyp) (ptr : addr) (uv : uvalue) : MemPropT MemState unit :=][write_uvalue_spec]]
- [[file:src/coq/Handlers/MemoryModel.v::Definition allocate_dtyp_spec (dt : dtyp) : MemPropT MemState addr :=][allocate_dtyp_spec]]

These specifications are what's ultimately used to [[file:src/coq/Handlers/MemoryModel.v::Definition handle_memory_prop : MemoryE ~> MemPropT MemState][handle memory events]] in our propositional model of LLVM.

** Executable Memory Model

The interface to the executable memory model is contained in [[file:src/coq/Handlers/MemoryModel.v::From Vellvm.Syntax Require
 Import][src/coq/Handlers/MemoryModel.v]] in two files, just like the
specification.

- [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelExecPrimitives]]
- [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExec (LP : LLVMParams) (MP : MemoryParams LP) (MMEP : MemoryModelExecPrimitives LP MP).][MemoryModelExec]]

[[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelExecPrimitives]] is what needs to be implemented when
creating an instance of the LLVM memory model, and [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExec (LP : LLVMParams) (MP : MemoryParams LP) (MMEP : MemoryModelExecPrimitives LP MP).][MemoryModelExec]] is
derived from it.

To implement [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelExecPrimitives]] we need to provide
implementations for low-level operations that read / write individual
bytes, allocate a block of bytes on the stack / heap, as well as
functions for freeing heap allocated blocks and stack allocated
bytes. Additionally some correctness lemmas must be provided for each
of these operations -- the executable operations must agree with their
specifications.

[[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExec (LP : LLVMParams) (MP : MemoryParams LP) (MMEP : MemoryModelExecPrimitives LP MP).][MemoryModelExec]] is derived from [[file:src/coq/Handlers/MemoryModel.v::Module Type MemoryModelExecPrimitives (LP : LLVMParams) (MP : MemoryParams LP).][MemoryModelExecPrimitives]], and it
implements aggregate operations (such as reads / writes of abstract
LLVM values, instead of just individual bytes), and also provides
handlers for memory events for the executable interpreter of LLVM.

** Other Memory Model Odds and Ends

- MonadStoreId
- MonadProvenance
- Memory events?

** Refinement Relations

The LLVM specification and executable interpreter are both implemented
with several "layers", with each type of abstract event being handled
in its own layer. There is a refinement relation between programs at
each of these layers, starting with [[file:src/coq/Theory/Refinement.v::Definition refine_L0: relation (itree L0 dvalue) := eutt eq.][refine_L0 in
src/coq/Theory/Refinement.v]].

- refine_L0: Equivalence relation before interpreting any events, this is just ~eutt~.
- refine_L1: After interpreting global variable events, ~eutt~, but ignoring the final global variable state.
- refine_L2: After local variable events, ~eutt~ ignoring local variable state.
- refine_L3: After ~MemoryE~ events.
- refine_L4: After ~PickeE~ events for nondeterministic values.
- refine_L5: Relationship between programs taking undefined behaviour into account.
- refine_L6: Relationship between programs taking out-of-memory events into account.

*** Out of Memory Refinement

[[file:src/coq/Theory/Refinement.v::Definition refine_L6 : relation ((itree L4 (MemState * (store_id * (local_env * stack * (global_env * dvalue))))) -> Prop)][refine_L6]] relies upon the [[file:src/coq/Handlers/OOM.v::Definition refine_OOM {T} (RR : relation T) (sources : PropT Effout T) (target : itree Effout T) : Prop][refine_OOM]] relation found in [[file:src/coq/Handlers/OOM.v::Definition refine_OOM {T} (RR : relation T) (sources : PropT Effout T) (target : itree Effout T) :
 Prop][src/coq/Handlers/OOM.v]].

The bulk of this definition is here:

#+begin_src coq
  Definition OOM_handler : OOME ~> PropT Effout
    (* Any tree is accepted as long as OOM is raised *)
    := fun T oome source => True.

  Definition refine_OOM_handler : Effin ~> PropT Effout
    := case_ E_trigger_model_prop (case_ OOM_handler F_trigger_model_prop).

  Definition refine_OOM_h {T} (RR : relation T) (source target : itree Effout T) : Proph
    := interp_prop (Basics.flip RR) refine_OOM_handler (@oom_k_spec) target source.

  Definition refine_OOM {T} (RR : relation T) (sources : PropT Effout T) (target : itree Effout T) : Prop
    := exists source, sources source /\ refine_OOM_h RR source target.
#+end_src

At a high level, if we have two programs ~A~ and ~B~, we want to say
that ~B~ is an out-of-memory refinement of ~A~ if ~B~ is ~eutt~
program ~A~ up to the point where ~B~ runs out of memory. I.e., ~A~
and ~B~ are equivalent, except ~B~ may raise ~OOM~ at any point
instead of continuing to compute.

With [[file:src/coq/Handlers/OOM.v::Definition refine_OOM {T} (RR : relation T) (sources : PropT Effout T) (target : itree Effout T) : Prop][refine_OOM]] we have a set of behaviours for our source program
(because there's non-determinism introduced by ~undef~ values and UB),
and we say that a ~target~ behaviour is a refinement of this set of
behaviours, if there exists an ~itree~ (~source~) in the set of source
behaviours such that ~source~ is equivalent to the ~target~ up to the
point where the target may raise ~OOM~.

*** Refinement Relations between Memory Model Instances

Each instance of LLVM interpreters and specs is a module which is
instantiated with a module for the memory model. Our approach involves
two-phases of compilation, starting with a version of LLVM with
infinite memory, and converting this to a version of LLVM with finite
memory. This lowering can be found in the file [[file:src/coq/Semantics/InfiniteToFinite.v::From Coq Require Import][InfiniteToFinite.v]].

One of the complications is that our LLVM values, [[file:src/coq/Semantics/DynamicValues.v::Inductive dvalue : Set :=][~dvalue~]] and [[file:src/coq/Semantics/DynamicValues.v::Inductive uvalue : Type
 :=][~uvalue~]], contain addresses, and therefor depend on the memory
model. As ~dvalues~ and ~uvalues~ are part of the event types, for
instance [[file:src/coq/Semantics/LLVMEvents.v::Variant MemoryE : Type -> Type :=][here]], we have to convert infinite LLVM events into finite
LLVM events. This is implemented in the [[file:src/coq/Semantics/InfiniteToFinite.v::Module EventConvert (LP1 : LLVMParams) (LP2 : LLVMParams) (AC : AddrConvert LP1.ADDR LP2.ADDR) (AC2 : AddrConvert LP2.ADDR LP1.ADDR) (E1 : LLVM_INTERACTIONS LP1.ADDR LP1.IP LP1.SIZEOF) (E2 : LLVM_INTERACTIONS LP2.ADDR LP2.IP LP2.SIZEOF).][EventConvert]] module.

The refinement relation between infinite and finite memory models can
be found in the [[file:src/coq/Semantics/InfiniteToFinite.v::Module InfiniteToFinite : LangRefine InterpreterStackBigIntptr InterpreterStack64BitIntptr FinAddrConvert FinAddrConvert TopLevelBigIntptr TopLevel64BitIntptr TopLevelRefinements64BitIntptr.][InfiniteToFinite]] module, with the main lemmas being [[file:src/coq/Semantics/InfiniteToFinite.v::Lemma refine_E1E2_L6_transitive
 :][refine_E1E2_L6_transitive]] and [[file:src/coq/Semantics/InfiniteToFinite.v::Lemma model_E1E2_L6_sound :][model_E1E2_L6_sound]].

** Handling of Undefined Behaviour

We handle UB events using [[file:src/coq/Handlers/UndefinedBehaviour.v::Definition model_UB {T} (ts : PropT Eff T) : PropT Eff T:=][model_UB in UndefinedBehaviour.v]].

#+begin_src coq
  Definition model_UB {T} (ts : PropT Eff T) : PropT Eff T:=
    fun t =>
      ts t \/ (exists ub, ts ub /\ contains_UB ub).

#+end_src

Given a set of ~itrees~, ~ts~, we say that a target ~itree~, ~t~ is
contained within the set of behaviours ~ts~ whenever ~t~ is in ~ts~,
or if there exists a trace ~ub~ in ~ts~ that [[file:src/coq/Theory/ContainsUB.v::Inductive contains_UB {R} : itree Eff R -> Prop :=][contains_UB]]. The [[file:src/coq/Theory/ContainsUB.v::Inductive contains_UB {R} : itree Eff R -> Prop
 :=][contains_UB]] predicate within [[file:src/coq/Theory/ContainsUB.v::Inductive contains_UB {R} : itree Eff R -> Prop :=][src/coq/Theory/ContainsUB.v]] holds
whenever the ~itree~ contains an undefined behaviour event.

#+begin_src coq
  Inductive contains_UB {R} : itree Eff R -> Prop :=
  | CrawlTau  : forall t1 t2, t2 ≅ Tau t1 -> contains_UB t1 -> contains_UB t2
  | CrawlVis1 : forall Y (e : (E +' F) Y) x k t2, t2 ≅ (vis e k) -> contains_UB (k x) -> contains_UB t2
  | CrawlVis2 : forall Y (e : G Y) x k t2, t2 ≅ (vis e k) -> contains_UB (k x) -> contains_UB t2
  | FindUB    : forall s k t2, t2 ≅ (vis (subevent _ (ThrowUB s)) k) -> contains_UB t2.
#+end_src

** More stuff

- toplevel theorems to definitions
